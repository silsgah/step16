"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var clone_1 = tslib_1.__importDefault(require("lodash/clone"));
var randombytes_1 = tslib_1.__importDefault(require("randombytes"));
var stellar_base_1 = require("stellar-base");
var errors_1 = require("./errors");
var Utils;
(function (Utils) {
    function buildChallengeTx(serverKeypair, clientAccountID, anchorName, timeout, networkPassphrase) {
        if (timeout === void 0) { timeout = 300; }
        var account = new stellar_base_1.Account(serverKeypair.publicKey(), "-1");
        var now = Math.floor(Date.now() / 1000);
        var value = randombytes_1.default(48).toString("base64");
        var transaction = new stellar_base_1.TransactionBuilder(account, {
            fee: stellar_base_1.BASE_FEE,
            networkPassphrase: networkPassphrase,
            timebounds: {
                minTime: now,
                maxTime: now + timeout,
            },
        })
            .addOperation(stellar_base_1.Operation.manageData({
            name: anchorName + " auth",
            value: value,
            source: clientAccountID,
        }))
            .build();
        transaction.sign(serverKeypair);
        return transaction
            .toEnvelope()
            .toXDR("base64")
            .toString();
    }
    Utils.buildChallengeTx = buildChallengeTx;
    function readChallengeTx(challengeTx, serverAccountId, networkPassphrase) {
        var _a;
        var transaction = new stellar_base_1.Transaction(challengeTx, networkPassphrase);
        var sequence = Number.parseInt(transaction.sequence, 10);
        if (sequence !== 0) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction sequence number should be zero");
        }
        if (transaction.source !== serverAccountId) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction source account is not equal to the server's account");
        }
        if (transaction.operations.length !== 1) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction should contain exactly one operation");
        }
        var operation = transaction.operations[0];
        if (!operation.source) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction's operation should contain a source account");
        }
        var clientAccountID = operation.source;
        if (operation.type !== "manageData") {
            throw new errors_1.InvalidSep10ChallengeError("The transaction's operation type should be 'manageData'");
        }
        if (transaction.timeBounds &&
            Number.parseInt((_a = transaction.timeBounds) === null || _a === void 0 ? void 0 : _a.maxTime, 10) === stellar_base_1.TimeoutInfinite) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction requires non-infinite timebounds");
        }
        if (!validateTimebounds(transaction)) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction has expired");
        }
        if (Buffer.from(operation.value.toString(), "base64").length !== 48) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction's operation value should be a 64 bytes base64 random string");
        }
        return { tx: transaction, clientAccountID: clientAccountID };
    }
    Utils.readChallengeTx = readChallengeTx;
    function verifyChallengeTxThreshold(challengeTx, serverAccountID, networkPassphrase, threshold, signerSummary) {
        var _a;
        var signers = signerSummary.map(function (signer) { return signer.key; });
        var signersFound = verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers);
        var weight = 0;
        var _loop_1 = function (signer) {
            var sigWeight = ((_a = signerSummary.find(function (s) { return s.key === signer; })) === null || _a === void 0 ? void 0 : _a.weight) || 0;
            weight += sigWeight;
        };
        for (var _i = 0, signersFound_1 = signersFound; _i < signersFound_1.length; _i++) {
            var signer = signersFound_1[_i];
            _loop_1(signer);
        }
        if (weight < threshold) {
            throw new errors_1.InvalidSep10ChallengeError("signers with weight " + weight + " do not meet threshold " + threshold + "\"");
        }
        return signersFound;
    }
    Utils.verifyChallengeTxThreshold = verifyChallengeTxThreshold;
    function verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers) {
        var tx = readChallengeTx(challengeTx, serverAccountID, networkPassphrase).tx;
        var serverKP;
        try {
            serverKP = stellar_base_1.Keypair.fromPublicKey(serverAccountID);
        }
        catch (err) {
            throw new Error("Couldn't infer keypair from the provided 'serverAccountID': " +
                err.message);
        }
        var clientSigners = new Set();
        for (var _i = 0, signers_1 = signers; _i < signers_1.length; _i++) {
            var signer = signers_1[_i];
            if (signer === serverKP.publicKey()) {
                continue;
            }
            if (signer.charAt(0) !== "G") {
                continue;
            }
            clientSigners.add(signer);
        }
        if (clientSigners.size === 0) {
            throw new errors_1.InvalidSep10ChallengeError("No verifiable client signers provided, at least one G... address must be provided");
        }
        var allSigners = tslib_1.__spreadArrays([
            serverKP.publicKey()
        ], Array.from(clientSigners));
        var signersFound = gatherTxSigners(tx, allSigners);
        if (signersFound.indexOf(serverKP.publicKey()) === -1) {
            throw new errors_1.InvalidSep10ChallengeError("Transaction not signed by server: '" + serverKP.publicKey() + "'");
        }
        if (signersFound.length === 1) {
            throw new errors_1.InvalidSep10ChallengeError("None of the given signers match the transaction signatures");
        }
        if (signersFound.length !== tx.signatures.length) {
            throw new errors_1.InvalidSep10ChallengeError("Transaction has unrecognized signatures");
        }
        signersFound.splice(signersFound.indexOf(serverKP.publicKey()), 1);
        return signersFound;
    }
    Utils.verifyChallengeTxSigners = verifyChallengeTxSigners;
    function verifyChallengeTx(challengeTx, serverAccountId, networkPassphrase) {
        console.warn("`Utils#verifyChallengeTx` is deprecated. Please use `Utils#verifyChallengeTxThreshold`.");
        var _a = readChallengeTx(challengeTx, serverAccountId, networkPassphrase), tx = _a.tx, clientAccountID = _a.clientAccountID;
        if (!verifyTxSignedBy(tx, serverAccountId)) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction is not signed by the server");
        }
        if (!verifyTxSignedBy(tx, clientAccountID)) {
            throw new errors_1.InvalidSep10ChallengeError("The transaction is not signed by the client");
        }
        return true;
    }
    Utils.verifyChallengeTx = verifyChallengeTx;
    function verifyTxSignedBy(transaction, accountID) {
        return gatherTxSigners(transaction, [accountID]).length !== 0;
    }
    Utils.verifyTxSignedBy = verifyTxSignedBy;
    function gatherTxSigners(transaction, signers) {
        var hashedSignatureBase = transaction.hash();
        var txSignatures = clone_1.default(transaction.signatures);
        var signersFound = new Set();
        for (var _i = 0, signers_2 = signers; _i < signers_2.length; _i++) {
            var signer = signers_2[_i];
            if (txSignatures.length === 0) {
                break;
            }
            var keypair = void 0;
            try {
                keypair = stellar_base_1.Keypair.fromPublicKey(signer);
            }
            catch (err) {
                throw new errors_1.InvalidSep10ChallengeError("Signer is not a valid address: " + err.message);
            }
            for (var i = 0; i < txSignatures.length; i++) {
                var decSig = txSignatures[i];
                if (!decSig.hint().equals(keypair.signatureHint())) {
                    continue;
                }
                if (keypair.verify(hashedSignatureBase, decSig.signature())) {
                    signersFound.add(signer);
                    txSignatures.splice(i, 1);
                    break;
                }
            }
        }
        return Array.from(signersFound);
    }
    Utils.gatherTxSigners = gatherTxSigners;
    function validateTimebounds(transaction) {
        if (!transaction.timeBounds) {
            return false;
        }
        var now = Math.floor(Date.now() / 1000);
        var _a = transaction.timeBounds, minTime = _a.minTime, maxTime = _a.maxTime;
        return (now >= Number.parseInt(minTime, 10) && now <= Number.parseInt(maxTime, 10));
    }
})(Utils = exports.Utils || (exports.Utils = {}));
//# sourceMappingURL=utils.js.map